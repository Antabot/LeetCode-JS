# 剑指 Offer 题解思路

题目出处：[https://leetcode-cn.com/problemset/lcof/](https://leetcode-cn.com/problemset/lcof/)

### lcof03-数组中重复的数字

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

该题重在数字范围确定，因此可使用同样长度的数组记录其出现次数。如范围不确定，可考虑使用 HashMap（JS 需要自己实现）。另外经过尝试，先快排再遍历比对超时😅。



### lcof04-二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

该题重在搜索方法。从上至下，从右至左搜索可以保证一个不漏，且可以筛选掉一部分值。

Tips: JS 中判断最好严格使用 ===，否则一些错误难以发现，比如 if 语句中单词拼写错误，结果恒为假但没有提示信息。

### lcof05-替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。


JS 字符串可直接使用下标访问字符，但无法修改。编写字符串替换函数（split、join）后遍历判断即可。

### lcof06-从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

由于 JS Array 的特性，可以遍历 push 再 reverse()，也可以递归。

### lcof07-重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

分治递归。（考虑使用迭代进一步提高效率）

### lcof09-用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

使用 JS Array 的 pop() push() 方法模拟栈，注意删除队列头后不必恢复原栈，可以在临时栈 pop 完之后再一次性补充。

### lcof10-斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)），答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

递归超时，转为迭代，注意取模运算即可。

### lcof11-旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

根据数据特征遍历查找拐点即可。

### lcof10-II-青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

动态规划问题，且符合斐波那契数列。只需想清楚 n 阶台阶的跳法是 n - 1 阶与 n - 2 阶跳法的总和即可。

### lcof12-矩阵中的路径

递归 DFS，性能待优化。

### lcof15-二进制中1的个数

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

位运算。 n &= n-1，每一次可以使 n 减少一个 1。

### lcof13-机器人的运动范围


广搜

### lcof14-I-剪绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。


动态规划 or 贪心 or 数学解法（取余、取模判断）

### lcof14-II-剪绳子 II

取模 1e9+7，需要循环走乘法

### lcof16-数值的整数次方

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

快速幂（二进制展开 + 移位）

### lcof17-打印从1到最大的n位数

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

全排列输出。（探索：考虑大数）

### lcof18-删除链表的节点

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

链表操作。

### lcof21-调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

双指针比对。

### lcof22-链表中倒数第k个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

快慢指针。

### lcof19-正则表达式匹配

转换为动态规划问题解决。f[i][j] 表示前 i 个 与前 j 个匹配

### lcof25-合并两个排序的链表

### lcof26-树的子结构

输入两棵二叉树A和B，判断B是不是A的子结构。

前序遍历 A，找到与 B 相同的节点时再同步遍历 B。

### lcof27-二叉树的镜像

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

递归调用每个节点，翻转左右节点。

### lcof28-对称的二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

广搜对称比较。

### lcof29-顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

顺时针移动，注意边界条件。

### lcof31-栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

利用辅助栈，边压入边对比，辅助栈顶与当前要弹出的数一样时则弹出。

### lcof32-I-从上到下打印二叉树

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

### lcof32-II-从上到下打印二叉树II

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

按层打印并用二维数组保存，可以记录每一层的长度并循环，每次把一层出队并把下一层入队。

### lcof32-III-从上到下打印二叉树III

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

思路一：在上题基础上判断奇偶行，偶行利用 unshift() 存数即可（或利用 reverse）。

思路二：奇偶层逻辑分离，奇数 shift() -> push(left) -> push(right)，偶数 pop() -> unshift(right) -> unshift(left)

### lcof33-二叉搜索树的后序遍历序列

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

找到关键点左右分治，递归判断是否符合二叉搜索树规则。

### lcof35-复杂链表的复制


请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

使用辅助 Map(node, index)，获取 [val, randomIndex] 数组，再新建没有 random 的链表，并放入 Map(index, node)，根据数组取得节点。

### lcof36-二叉搜索树与双向链表

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

中序遍历，全局变量保存前序节点

### lcof39-数组中超过一般的数

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。

Map 保存次数，一次遍历，超过一半返回。

### lcof40-最小的 k 个数

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

### lcof37-序列化二叉树

请实现两个函数，分别用来序列化和反序列化二叉树。

层序遍历（BFS）

### lcof42-连续子数组的最大和

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

动态规划

### lcof38-字符串的排列

输入一个字符串，打印出该字符串中字符的所有排列。

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

DFS，每一位依次选择一个数，并把该数与排列当前位置的数交换，递归向下一位数调用，迭代替换当前位数字。

### lcof30-包含min函数的栈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

辅助栈栈顶记录当前最小值。

### lcof34-二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

DFS,记录路径，回溯时弹出。


### lcof20-表示数值的字符串

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"-1E-16"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"及"12e+5.4"都不是。


有限状态自动机，判断每一位处于何种状态。

### lcof41-数据流中的中位数

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

双向链表，O(N), 堆排序，O(log(N))

### lcof43-1～n 整数中 1 出现的次数

输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

从后至前判断每一位可能出现 1 的次数。

### lcof44-数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

思路一：从 0 开始循环，一个数一个数地加并记录当前走到的索引位置，直到找到 n，超时。
思路二：算出当前 n 所处的位置是几位数的范围，再根据 n 与该范围最大值的差值寻找 n 对应的数。

### lcof45-把数组排成最小的数

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

设x、y 分别为数对应的字符串，需先证明若 Number(x + y) > Number(y + x)，则 x 应排在后面。

根据此规则，对数组进行排序即可。（快排为 NlogN）

### lcof46-把数字翻译成字符串

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。


动态规划。（带条件的爬楼梯问题）

### lcof47-礼物的最大价值

在一个 mn 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

动态规划，可以直接利用原棋盘实现原地算法。

### lcof48-最长不含重复字符的子字符串

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

双指针法。（循环中走回头路，则可以考虑用双指针法代替）

### lcof49-丑数

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

### lcof50-第一个只出现一次的字符

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

第一次遍历时用 map 记录次数，第二次遍历时只遍历 map 的 key 即可。

### lcof51-数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

经典算法，归并排序时获取逆序/顺序对。

解题技巧：O(n2) 的算法可以使用分治的方法降低时间复杂度。

**练习：**快排、归并的递归与迭代写法。

### lcof52-两个链表的第一个公共节点

输入两个链表，找出它们的第一个公共节点。

a + b - c = b + a - c

### lcof53-I-在排序数组中查找数字 I

统计一个数字在排序数组中出现的次数。

二分法。

### lcof53-II-0～n-1中缺失的数字

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

二分法，注意终止条件。

### lcof54-二叉搜索树的第k大节点

给定一棵二叉搜索树，请找出其中第k大的节点。

先 right 后 left，中序遍历

### lcof55-I-二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

DFS 或层序遍历。depth(root) = Math.max(root.left, root.right) + 1

### lcof55-II-平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

DFS + 剪枝。

### lcof56-I-数组中数字出现的次数

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

分组异或。（分组依据为异或后任意为 1 的一位）

### lcof56-II-数组中数字出现的次数-II

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

按位统计 1 出现的次数，除以 3 取余。

### lcof57-和为 s 的两个数字

输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。

对撞双指针。

### lcof57-II 和为 s 的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

滑动窗口，注意边界条件。

### lcof58-I 翻转单词顺序

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

库函数、双指针等。

### lcof58-II 左旋转字符串

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

三次翻转、切片、列表、字符串遍历拼接。

### lcof59-I 滑动窗口的最大值

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

单调队列。