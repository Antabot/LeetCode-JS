# 剑指 Offer 题解思路

题目出处：[https://leetcode-cn.com/problemset/lcof/](https://leetcode-cn.com/problemset/lcof/)

### lcof03-数组中重复的数字

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

该题重在数字范围确定，因此可使用同样长度的数组记录其出现次数。如范围不确定，可考虑使用 HashMap（JS 需要自己实现）。另外经过尝试，先快排再遍历比对超时😅。



### lcof04-二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

该题重在搜索方法。从上至下，从右至左搜索可以保证一个不漏，且可以筛选掉一部分值。

Tips: JS 中判断最好严格使用 ===，否则一些错误难以发现，比如 if 语句中单词拼写错误，结果恒为假但没有提示信息。

### lcof05-替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。


JS 字符串可直接使用下标访问字符，但无法修改。编写字符串替换函数（split、join）后遍历判断即可。

### lcof06-从尾到头打印链表

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

由于 JS Array 的特性，可以遍历 push 再 reverse()，也可以递归。

### lcof07-重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

分治递归。（考虑使用迭代进一步提高效率）

### lcof09-用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

使用 JS Array 的 pop() push() 方法模拟栈，注意删除队列头后不必恢复原栈，可以在临时栈 pop 完之后再一次性补充。

### lcof10-斐波那契数列

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)），答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

递归超时，转为迭代，注意取模运算即可。

### lcof11-旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

根据数据特征遍历查找拐点即可。

### lcof10-II-青蛙跳台阶问题

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

动态规划问题，且符合斐波那契数列。只需想清楚 n 阶台阶的跳法是 n - 1 阶与 n - 2 阶跳法的总和即可。

### lcof12-矩阵中的路径

递归 DFS，性能待优化。

### lcof15-二进制中1的个数

请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

位运算。 n &= n-1，每一次可以使 n 减少一个 1。

